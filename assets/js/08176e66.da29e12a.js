"use strict";(self.webpackChunkmy_learning_paths=self.webpackChunkmy_learning_paths||[]).push([[1821],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>g});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=a.createContext({}),p=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},c=function(e){var n=p(e.components);return a.createElement(l.Provider,{value:n},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),d=p(t),u=i,g=d["".concat(l,".").concat(u)]||d[u]||m[u]||r;return t?a.createElement(g,s(s({ref:n},c),{},{components:t})):a.createElement(g,s({ref:n},c))}));function g(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,s=new Array(r);s[0]=u;var o={};for(var l in n)hasOwnProperty.call(n,l)&&(o[l]=n[l]);o.originalType=e,o[d]="string"==typeof e?e:i,s[1]=o;for(var p=2;p<r;p++)s[p]=t[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},9680:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var a=t(7462),i=(t(7294),t(3905));const r={},s="Open Class",o={unversionedId:"programming/languages/kotlin/classes/open-class",id:"programming/languages/kotlin/classes/open-class",title:"Open Class",description:"In Kotlin, all classes are final by default, which means they cannot be inherited from. However, if you want to allow a class to be inherited from, you can mark it as open.",source:"@site/docs/programming/languages/kotlin/classes/open-class.md",sourceDirName:"programming/languages/kotlin/classes",slug:"/programming/languages/kotlin/classes/open-class",permalink:"/programming/languages/kotlin/classes/open-class",draft:!1,editUrl:"https://github.com/dennis-gonzales/dennis-gonzales.github.io/blob/main/docs/programming/languages/kotlin/classes/open-class.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Inner Class",permalink:"/programming/languages/kotlin/classes/inner-class"},next:{title:"Sealed Class",permalink:"/programming/languages/kotlin/classes/sealed-class"}},l={},p=[{value:"Defining an Open Class",id:"defining-an-open-class",level:2},{value:"Overriding Properties and Functions",id:"overriding-properties-and-functions",level:2},{value:"Implementing an Open Class",id:"implementing-an-open-class",level:2},{value:"Common Pitfalls and Best Practices",id:"common-pitfalls-and-best-practices",level:2},{value:"Unintentional Overriding",id:"unintentional-overriding",level:3},{value:"Using the Correct Visibility Modifier",id:"using-the-correct-visibility-modifier",level:3},{value:"Design Patterns",id:"design-patterns",level:2}],c={toc:p},d="wrapper";function m(e){let{components:n,...t}=e;return(0,i.kt)(d,(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"open-class"},"Open Class"),(0,i.kt)("p",null,"In Kotlin, all classes are final by default, which means they cannot be inherited from. However, if you want to allow a class to be inherited from, you can mark it as ",(0,i.kt)("inlineCode",{parentName:"p"},"open"),"."),(0,i.kt)("h2",{id:"defining-an-open-class"},"Defining an Open Class"),(0,i.kt)("p",null,"An open class is defined with the ",(0,i.kt)("inlineCode",{parentName:"p"},"open")," keyword, followed by the ",(0,i.kt)("inlineCode",{parentName:"p"},"class")," keyword, and the class name."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="OpenClassDefinition.kt"',title:'"OpenClassDefinition.kt"'},"open class Animal {\n    // Class body goes here\n}\n")),(0,i.kt)("h2",{id:"overriding-properties-and-functions"},"Overriding Properties and Functions"),(0,i.kt)("p",null,"In an open class, you can also mark properties and functions as ",(0,i.kt)("inlineCode",{parentName:"p"},"open"),". This allows them to be overridden in subclasses."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="OverridingPropertiesFunctions.kt"',title:'"OverridingPropertiesFunctions.kt"'},'open class Animal {\n    open var name: String = "Animal"\n    \n    open fun sound() {\n        println("The animal makes a sound.")\n    }\n}\n')),(0,i.kt)("p",null,"In the above example, ",(0,i.kt)("inlineCode",{parentName:"p"},"Animal")," is an open class with an open property ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," and an open function ",(0,i.kt)("inlineCode",{parentName:"p"},"sound"),"."),(0,i.kt)("h2",{id:"implementing-an-open-class"},"Implementing an Open Class"),(0,i.kt)("p",null,"An open class is meant to be inherited by other classes. The subclass can override the open properties and functions of the open class."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="ImplementOpenClass.kt"',title:'"ImplementOpenClass.kt"'},'open class Animal {\n    open var name: String = "Animal"\n    \n    open fun sound() {\n        println("The animal makes a sound.")\n    }\n}\n\nclass Dog : Animal() {\n    override var name: String = "Dog"\n    \n    override fun sound() {\n        println("The dog barks.")\n    }\n}\n')),(0,i.kt)("p",null,"In the above example, ",(0,i.kt)("inlineCode",{parentName:"p"},"Dog")," is a class that inherits from ",(0,i.kt)("inlineCode",{parentName:"p"},"Animal")," and overrides the ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," property and the ",(0,i.kt)("inlineCode",{parentName:"p"},"sound")," function."),(0,i.kt)("h2",{id:"common-pitfalls-and-best-practices"},"Common Pitfalls and Best Practices"),(0,i.kt)("h3",{id:"unintentional-overriding"},"Unintentional Overriding"),(0,i.kt)("p",null,"A common pitfall when working with open classes is unintentional overriding. If a subclass has a property or function with the same name as a property or function in the superclass, it will override the superclass property or function, which might not be what you intended. To avoid this, always explicitly mark properties and functions that you want to allow to be overridden with the ",(0,i.kt)("inlineCode",{parentName:"p"},"open")," keyword, and use the ",(0,i.kt)("inlineCode",{parentName:"p"},"override")," keyword in the subclass."),(0,i.kt)("h3",{id:"using-the-correct-visibility-modifier"},"Using the Correct Visibility Modifier"),(0,i.kt)("p",null,"By default, all properties and functions in a Kotlin class are public. If you're creating an open class, think carefully about the visibility of your properties and functions. If a property or function should not be accessible to subclasses or other classes, use the appropriate visibility modifier (",(0,i.kt)("inlineCode",{parentName:"p"},"private"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"protected"),", or ",(0,i.kt)("inlineCode",{parentName:"p"},"internal"),")."),(0,i.kt)("h2",{id:"design-patterns"},"Design Patterns"),(0,i.kt)("p",null,"In the context of design patterns, open classes are often used as a base class for other classes. Here are a few examples:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"In the Template Method pattern, an abstract class defines the skeleton of an algorithm, and concrete subclasses provide the implementation."),(0,i.kt)("li",{parentName:"ul"},"In the Strategy pattern, different strategies can be implemented as subclasses of an open class."),(0,i.kt)("li",{parentName:"ul"},"In the Factory pattern, different types of products can be subclasses of an open class.")),(0,i.kt)("p",null,"Understanding open classes is essential for object-oriented programming in Kotlin. They allow you to create a common interface for a group of related classes."))}m.isMDXComponent=!0}}]);