"use strict";(self.webpackChunkmy_learning_paths=self.webpackChunkmy_learning_paths||[]).push([[7195],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),u=p(n),h=o,m=u["".concat(l,".").concat(h)]||u[h]||d[h]||i;return n?a.createElement(m,s(s({ref:t},c),{},{components:n})):a.createElement(m,s({ref:t},c))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,s=new Array(i);s[0]=h;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r[u]="string"==typeof e?e:o,s[1]=r;for(var p=2;p<i;p++)s[p]=n[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},6045:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>p});var a=n(7462),o=(n(7294),n(3905));const i={},s="Android Practices",r={unversionedId:"programming/languages/kotlin/coroutines/android-practices",id:"programming/languages/kotlin/coroutines/android-practices",title:"Android Practices",description:"This page presents several best practices that have a positive impact by making your app more scalable and testable when using coroutines.",source:"@site/docs/programming/languages/kotlin/coroutines/android-practices.md",sourceDirName:"programming/languages/kotlin/coroutines",slug:"/programming/languages/kotlin/coroutines/android-practices",permalink:"/programming/languages/kotlin/coroutines/android-practices",draft:!1,editUrl:"https://github.com/dennis-gonzales/dennis-gonzales.github.io/blob/main/docs/programming/languages/kotlin/coroutines/android-practices.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Coroutines",permalink:"/programming/languages/kotlin/coroutines/"},next:{title:"C",permalink:"/programming/languages/c"}},l={},p=[{value:"Best Practices",id:"best-practices",level:2},{value:"Inject Dispatchers",id:"inject-dispatchers",level:3},{value:"Suspend Functions Should Be Safe To Call From The Main Thread",id:"suspend-functions-should-be-safe-to-call-from-the-main-thread",level:3},{value:"ViewModel Should Create Coroutines",id:"viewmodel-should-create-coroutines",level:3},{value:"Don&#39;t Expose Mutable Types",id:"dont-expose-mutable-types",level:3},{value:"The Data and Business Layer Should Expose Suspend Functions and Flows",id:"the-data-and-business-layer-should-expose-suspend-functions-and-flows",level:3},{value:"Creating Coroutines in The Business and Data Layer",id:"creating-coroutines-in-the-business-and-data-layer",level:3},{value:"Inject TestDispatchers in Tests",id:"inject-testdispatchers-in-tests",level:3},{value:"Avoid GlobalScope",id:"avoid-globalscope",level:3},{value:"Make Your Coroutine Cancellable",id:"make-your-coroutine-cancellable",level:3},{value:"Watch Out for Exceptions",id:"watch-out-for-exceptions",level:3},{value:"Example Implementation in MVVM",id:"example-implementation-in-mvvm",level:2}],c={toc:p},u="wrapper";function d(e){let{components:t,...n}=e;return(0,o.kt)(u,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"android-practices"},"Android Practices"),(0,o.kt)("p",null,"This page presents several best practices that have a positive impact by making your app more scalable and testable when using coroutines."),(0,o.kt)("h2",{id:"best-practices"},"Best Practices"),(0,o.kt)("p",null,"These tips can be applied to a broad spectrum of apps. However, you should treat them as guidelines and adapt them to your requirements as needed."),(0,o.kt)("h3",{id:"inject-dispatchers"},"Inject Dispatchers"),(0,o.kt)("p",null,"When creating new coroutines or calling ",(0,o.kt)("inlineCode",{parentName:"p"},"withContext"),", avoid hardcoding Dispatchers. Instead, inject them. This practice makes testing easier as you can replace the dispatchers in unit and instrumentation tests with a test dispatcher. It helps to make your tests more deterministic."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Do:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"class NewsRepository(\n    private val defaultDispatcher: CoroutineDispatcher = Dispatchers.Default\n) {\n    suspend fun loadNews() = withContext(defaultDispatcher) { /* ... */ }\n}\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Don't:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"class NewsRepository {\n    suspend fun loadNews() = withContext(Dispatchers.Default) { /* ... */ }\n}\n")),(0,o.kt)("h3",{id:"suspend-functions-should-be-safe-to-call-from-the-main-thread"},"Suspend Functions Should Be Safe To Call From The Main Thread"),(0,o.kt)("p",null,"All suspend functions should be main-safe, i.e., they should be safe to call from the main thread without blocking the UI or performing long-running operations. Any class performing such operations in a coroutine must ensure these tasks are dispatched to a background thread."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"withContext")," function is a tool to facilitate this transition. It changes the ",(0,o.kt)("inlineCode",{parentName:"p"},"CoroutineDispatcher")," determining the thread on which the coroutine runs. For example, ",(0,o.kt)("inlineCode",{parentName:"p"},"Dispatchers.Main")," is for the main thread, ",(0,o.kt)("inlineCode",{parentName:"p"},"Dispatchers.IO")," is for I/O tasks, and ",(0,o.kt)("inlineCode",{parentName:"p"},"Dispatchers.Default")," is for CPU-intensive tasks."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"class NewsRepository(private val ioDispatcher: CoroutineDispatcher) {\n    suspend fun fetchLatestNews(): List<Article> {\n        return withContext(ioDispatcher) { /* Long-running I/O operation */ }\n    }\n}\n")),(0,o.kt)("p",null,"In this example, ",(0,o.kt)("inlineCode",{parentName:"p"},"fetchLatestNews")," is a main-safe suspending function as it offloads potential long-running operations to a background thread, using ",(0,o.kt)("inlineCode",{parentName:"p"},"withContext(ioDispatcher)"),". The ",(0,o.kt)("inlineCode",{parentName:"p"},"ioDispatcher")," is typically ",(0,o.kt)("inlineCode",{parentName:"p"},"Dispatchers.IO")," or any other dispatcher optimized for I/O operations."),(0,o.kt)("p",null,"This pattern enhances the scalability of your app. The callers of suspend functions need not worry about choosing the right ",(0,o.kt)("inlineCode",{parentName:"p"},"Dispatcher")," for the job. The responsibility of selecting the appropriate ",(0,o.kt)("inlineCode",{parentName:"p"},"Dispatcher")," lies with the class that performs the work."),(0,o.kt)("p",null,"This method of injecting the ",(0,o.kt)("inlineCode",{parentName:"p"},"CoroutineDispatcher")," also improves testability by allowing the replacement of the dispatcher with a different one in unit tests, such as ",(0,o.kt)("inlineCode",{parentName:"p"},"Dispatchers.Unconfined")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"TestCoroutineDispatcher"),", enhancing test predictability and control."),(0,o.kt)("h3",{id:"viewmodel-should-create-coroutines"},"ViewModel Should Create Coroutines"),(0,o.kt)("p",null,"ViewModel classes should create coroutines instead of exposing suspend functions to perform business logic. If you need to expose state using a stream of data, or only a single value needs to be emitted, suspend functions in the ViewModel can be useful."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Do:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"class LatestNewsViewModel(\n    private val getLatestNewsWithAuthors: GetLatestNewsWithAuthorsUseCase\n) : ViewModel() {\n    private val _uiState = MutableStateFlow<LatestNewsUiState>(LatestNewsUiState.Loading)\n    val uiState: StateFlow<LatestNewsUiState> = _uiState\n\n    fun loadNews() {\n        viewModelScope.launch {\n            val latestNewsWithAuthors = getLatestNewsWithAuthors()\n            _uiState.value = LatestNewsUiState.Success(latestNewsWithAuthors)\n        }\n    }\n}\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Don't:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"class LatestNewsViewModel(\n    private val getLatestNewsWithAuthors: GetLatestNewsWithAuthorsUseCase\n) : ViewModel() {\n    suspend fun loadNews() = getLatestNewsWithAuthors()\n}\n")),(0,o.kt)("h3",{id:"dont-expose-mutable-types"},"Don't Expose Mutable Types"),(0,o.kt)("p",null,"To avoid uncontrolled changes to mutable types, prefer exposing immutable types to other classes."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Do:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"class LatestNewsViewModel : ViewModel() {\n    private val _uiState = MutableStateFlow(LatestNewsUiState.Loading)\n    val uiState: StateFlow<LatestNewsUiState> = _uiState\n    /* ... */\n}\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Don't:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"class LatestNewsViewModel : ViewModel() {\n    val uiState = MutableStateFlow(LatestNewsUiState.Loading)\n    /* ... */\n}\n")),(0,o.kt)("h3",{id:"the-data-and-business-layer-should-expose-suspend-functions-and-flows"},"The Data and Business Layer Should Expose Suspend Functions and Flows"),(0,o.kt)("p",null,"To allow the caller to control the execution and lifecycle of the work happening in those layers, classes in the data and business layers should expose suspend functions for one-shot calls and Flow to notify about data changes."),(0,o.kt)("p",null,"Example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"class ExampleRepository {\n    suspend fun makeNetworkRequest() { /* ... */ }\n    fun getExamples(): Flow<Example> { /* ... */ }\n}\n")),(0,o.kt)("h3",{id:"creating-coroutines-in-the-business-and-data-layer"},"Creating Coroutines in The Business and Data Layer"),(0,o.kt)("p",null,"Depending on the nature of the work, you may need to create coroutines in the data or business layer."),(0,o.kt)("p",null,"Example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"class GetAllBooksAndAuthorsUseCase(\n    private val booksRepository: BooksRepository,\n    private val authorsRepository: AuthorsRepository,\n) {\n    suspend fun getBookAndAuthors(): BookAndAuthors {\n        return coroutineScope {\n            val books = async { booksRepository.getAllBooks() }\n            val authors = async { authorsRepository.getAllAuthors() }\n            BookAndAuthors(books.await(), authors.await())\n        }\n    }\n}\n")),(0,o.kt)("h3",{id:"inject-testdispatchers-in-tests"},"Inject TestDispatchers in Tests"),(0,o.kt)("p",null,"In your tests, inject an instance of ",(0,o.kt)("inlineCode",{parentName:"p"},"TestDispatcher"),". Two implementations are available in the ",(0,o.kt)("inlineCode",{parentName:"p"},"kotlinx-coroutines-test")," library: ",(0,o.kt)("inlineCode",{parentName:"p"},"StandardTestDispatcher")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"UnconfinedTestDispatcher"),"."),(0,o.kt)("p",null,"Example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"class ArticlesRepositoryTest {\n    @Test\n    fun testBookmarkArticle() = runTest {\n        val testDispatcher = UnconfinedTestDispatcher(testScheduler)\n        val articlesDataSource = FakeArticlesDataSource()\n        val repository = ArticlesRepository(articlesDataSource, testDispatcher)\n        val article = Article()\n        repository.bookmarkArticle(article)\n        assertThat(articlesDataSource.isBookmarked(article)).isTrue()\n    }\n}\n")),(0,o.kt)("h3",{id:"avoid-globalscope"},"Avoid GlobalScope"),(0,o.kt)("p",null,"Avoid using ",(0,o.kt)("inlineCode",{parentName:"p"},"GlobalScope")," as it promotes hardcoding values, makes testing difficult, and doesn't allow a common ",(0,o.kt)("inlineCode",{parentName:"p"},"CoroutineContext")," for all coroutines."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Do:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"class ArticlesRepository(\n    private val articlesDataSource: ArticlesDataSource,\n    private val externalScope: CoroutineScope = GlobalScope,\n    private val defaultDispatcher: CoroutineDispatcher = Dispatchers.Default\n) {\n    suspend fun bookmarkArticle(article: Article) {\n        externalScope.launch(defaultDispatcher) {\n            articlesDataSource.bookmarkArticle(article)\n        }\n            .join()\n    }\n}\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Don't:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"class ArticlesRepository(\n    private val articlesDataSource: ArticlesDataSource,\n) {\n    suspend fun bookmarkArticle(article: Article) {\n        GlobalScope.launch {\n            articlesDataSource.bookmarkArticle(article)\n        }\n            .join()\n    }\n}\n")),(0,o.kt)("h3",{id:"make-your-coroutine-cancellable"},"Make Your Coroutine Cancellable"),(0,o.kt)("p",null,"Ensure your coroutine can be cancelled by checking its status before executing long tasks."),(0,o.kt)("p",null,"Example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"someScope.launch {\n    for(file in files) {\n        ensureActive() // Check for cancellation\n        readFile(file)\n    }\n}\n")),(0,o.kt)("h3",{id:"watch-out-for-exceptions"},"Watch Out for Exceptions"),(0,o.kt)("p",null,"Catch likely exceptions in the body of any coroutines created with ",(0,o.kt)("inlineCode",{parentName:"p"},"viewModelScope")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"lifecycleScope")," to prevent your app from crashing."),(0,o.kt)("p",null,"Example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"class LoginViewModel(\n    private val loginRepository: LoginRepository\n) : ViewModel() {\n    fun login(username: String, token: String) {\n        viewModelScope.launch {\n            try {\n                loginRepository.login(username, token)\n                // Notify view user logged in successfully\n            } catch (exception: IOException) {\n                // Notify view login attempt failed\n            }\n        }\n    }\n}\n")),(0,o.kt)("p",null,"Remember, these are guidelines and they should be adapted to your requirements as needed."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Related Links:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://developer.android.com/kotlin/coroutines/coroutines-best-practices"},"Google Android: Coroutines Practices"))),(0,o.kt)("h2",{id:"example-implementation-in-mvvm"},"Example Implementation in MVVM"),(0,o.kt)("p",null,"Sure, here's a simple example of an MVVM pattern in Android using Kotlin and Coroutines."),(0,o.kt)("p",null,"Firstly, let's define a ",(0,o.kt)("inlineCode",{parentName:"p"},"Data")," model."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="./model/Data.kt"',title:'"./model/Data.kt"'},"data class Data(val id: Int, val name: String)\n")),(0,o.kt)("p",null,"Next, we create a ",(0,o.kt)("inlineCode",{parentName:"p"},"Repository")," to fetch our data."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="./model/Repository.kt"',title:'"./model/Repository.kt"'},'class Repository(private val ioDispatcher: CoroutineDispatcher = Dispatchers.IO) {\n\n    suspend fun fetchData(): Data {\n        return withContext(ioDispatcher) {\n            // Here, we\'re simulating a network or database operation\n            delay(1000)  // Simulate network delay\n            Data(1, "Example Data")\n        }\n    }\n}\n')),(0,o.kt)("p",null,"Now, we define the ",(0,o.kt)("inlineCode",{parentName:"p"},"ViewModel"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="./viewmodel/MainViewModel.kt"',title:'"./viewmodel/MainViewModel.kt"'},"class MainViewModel(private val repository: Repository) : ViewModel() {\n\n    private val _data = MutableLiveData<Data>()\n    val data: LiveData<Data> get() = _data\n\n    fun fetchData() {\n        viewModelScope.launch {\n            _data.value = repository.fetchData()\n        }\n    }\n}\n")),(0,o.kt)("p",null,"Finally, in our ",(0,o.kt)("inlineCode",{parentName:"p"},"Activity"),", we observe the LiveData from the ViewModel."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="./MainActivity.kt"',title:'"./MainActivity.kt"'},"class MainActivity : AppCompatActivity() {\n\n    private lateinit var viewModel: MainViewModel\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        // Initialize the ViewModel\n        viewModel = ViewModelProvider(this).get(MainViewModel::class.java)\n\n        // Observe the LiveData from the ViewModel\n        viewModel.data.observe(this, Observer { data ->\n            // Update UI with the data\n            updateUI(data)\n        })\n\n        // Fetch data\n        viewModel.fetchData()\n    }\n\n    private fun updateUI(data: Data) {\n        // Update UI with the data here\n    }\n}\n")),(0,o.kt)("p",null,"This is a basic example of how you can use Coroutines with the MVVM architecture in Android. Depending on the complexity of your project, you might need to add more layers or use additional libraries, like Room for database access or Retrofit for network calls."))}d.isMDXComponent=!0}}]);