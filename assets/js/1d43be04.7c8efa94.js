"use strict";(self.webpackChunkmy_learning_paths=self.webpackChunkmy_learning_paths||[]).push([[2131],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var a=n(7294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var o=a.createContext({}),p=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(o.Provider,{value:t},e.children)},m="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,i=e.originalType,o=e.parentName,u=r(e,["components","mdxType","originalType","parentName"]),m=p(n),c=l,d=m["".concat(o,".").concat(c)]||m[c]||h[c]||i;return n?a.createElement(d,s(s({ref:t},u),{},{components:n})):a.createElement(d,s({ref:t},u))}));function d(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var i=n.length,s=new Array(i);s[0]=c;var r={};for(var o in t)hasOwnProperty.call(t,o)&&(r[o]=t[o]);r.originalType=e,r[m]="string"==typeof e?e:l,s[1]=r;for(var p=2;p<i;p++)s[p]=n[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},275:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>p});var a=n(7462),l=(n(7294),n(3905));const i={},s="Tuple",r={unversionedId:"programming/languages/python/data-types/tuple",id:"programming/languages/python/data-types/tuple",title:"Tuple",description:"In Python, a tuple is an immutable sequence type. It is similar to a list in that it can contain elements of different types, but unlike lists, it cannot be changed once created (i.e., you cannot add, remove, or change elements).",source:"@site/docs/programming/languages/python/data-types/tuple.md",sourceDirName:"programming/languages/python/data-types",slug:"/programming/languages/python/data-types/tuple",permalink:"/programming/languages/python/data-types/tuple",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/programming/languages/python/data-types/tuple.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"List",permalink:"/programming/languages/python/data-types/list"},next:{title:"C",permalink:"/programming/languages/c"}},o={},p=[{value:"Understanding Tuple",id:"understanding-tuple",level:2},{value:"User-Defined Types",id:"user-defined-types",level:3},{value:"Nesting",id:"nesting",level:3},{value:"Hashability",id:"hashability",level:3},{value:"<strong>Related Links:</strong>",id:"related-links",level:4},{value:"Common Pitfalls",id:"common-pitfalls",level:2},{value:"Immutable But Contain Mutable Elements",id:"immutable-but-contain-mutable-elements",level:3},{value:"Single Element Tuples",id:"single-element-tuples",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Use When Data Shouldn&#39;t Change",id:"use-when-data-shouldnt-change",level:3},{value:"Unpacking",id:"unpacking",level:3},{value:"Return Multiple Values from a Function",id:"return-multiple-values-from-a-function",level:3}],u={toc:p},m="wrapper";function h(e){let{components:t,...n}=e;return(0,l.kt)(m,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"tuple"},"Tuple"),(0,l.kt)("p",null,"In Python, a tuple is an immutable sequence type. It is similar to a ",(0,l.kt)("a",{parentName:"p",href:"./list"},"list")," in that it can contain elements of different types, but unlike lists, it cannot be changed once created (i.e., you cannot add, remove, or change elements)."),(0,l.kt)("p",null,"Here's an example of a tuple:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="main.py"',title:'"main.py"'},'my_tuple = (1, "Hello", 3.14)\n')),(0,l.kt)("p",null,"You can access elements of a tuple:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="main.py"',title:'"main.py"'},'my_tuple = (1, "two", 3.0)\n\n# Access first element\nprint(my_tuple[0])  # Output: 1\n\n# Access second element\nprint(my_tuple[1])  # Output: two\n\n# Access last element\nprint(my_tuple[-1])  # Output: 3.0\n')),(0,l.kt)("h2",{id:"understanding-tuple"},"Understanding Tuple"),(0,l.kt)("p",null,"Tuple in Python can hold different types of data including integers, strings, floats, classes, other objects, and even other collections like lists, sets, and dictionaries. It also supports nesting, i.e., tuples can contain other tuples. Here's an example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="main.py"',title:'"main.py"'},'my_tuple = (1, "Hello", 3.14, [5, 6, 7], {\'name\': \'John\'}, ("another", "tuple"))\n')),(0,l.kt)("p",null,"In the above code, ",(0,l.kt)("inlineCode",{parentName:"p"},"my_tuple")," contains an integer, a string, a float, a list, a dictionary, and another tuple."),(0,l.kt)("h3",{id:"user-defined-types"},"User-Defined Types"),(0,l.kt)("p",null,"Moreover, Python's tuples can hold user-defined types, i.e., instances of user-defined classes. This is because Python is a dynamically-typed language, and its data structures, including tuples, do not require a uniform type for all elements."),(0,l.kt)("p",null,"For example, consider a user-defined class ",(0,l.kt)("inlineCode",{parentName:"p"},"Person"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="main.py"',title:'"main.py"'},"class Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n")),(0,l.kt)("p",null,"You can create a tuple that contains instances of this class:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="main.py"',title:'"main.py"'},'p1 = Person("Alice", 25)\np2 = Person("Bob", 30)\n\npeople = (p1, p2)  # This is a tuple containing Person objects\n')),(0,l.kt)("h3",{id:"nesting"},"Nesting"),(0,l.kt)("p",null,"The same applies to nested tuples:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="main.py"',title:'"main.py"'},"tuple1 = (1, 2, 3)\ntuple2 = (4, 5, 6)\n\nnested_tuple = (tuple1, tuple2)  # This is a tuple containing other tuples\n")),(0,l.kt)("h3",{id:"hashability"},"Hashability"),(0,l.kt)("p",null,"In terms of hashability, a Python tuple is hashable if all its elements are also hashable. In Python, an object is hashable if it has a hash value which never changes during its lifetime (it needs a ",(0,l.kt)("inlineCode",{parentName:"p"},"__hash__()")," method), and can be compared to other objects (it needs an ",(0,l.kt)("inlineCode",{parentName:"p"},"__eq__()")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"__cmp__()")," method). Hashable objects which compare equal must have the same hash value."),(0,l.kt)("p",null,"When you call ",(0,l.kt)("inlineCode",{parentName:"p"},"hash(my_tuple)"),", Python internally calls the ",(0,l.kt)("inlineCode",{parentName:"p"},"__hash__()")," method for the tuple object. This works by first checking if all elements of the tuple are hashable. If they are, it combines their hash values to generate a new hash value. If any element is not hashable (like lists or dictionaries), it raises a ",(0,l.kt)("inlineCode",{parentName:"p"},"TypeError"),"."),(0,l.kt)("p",null,"So, a tuple containing only hashable elements (like numbers, strings, or other hashable tuples) is itself hashable, while a tuple containing non-hashable elements (like lists or dictionaries) is not. For example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="main.py"',title:'"main.py"'},"hashable_tuple = (1, 2, 3)\nprint(hash(hashable_tuple))  # This will print a hash value\n\nnon_hashable_tuple = ([1, 2, 3], 4, 5)\nprint(hash(non_hashable_tuple))  # This will raise a TypeError\n")),(0,l.kt)("p",null,"Please note that instances of user-defined classes are hashable by default as they inherit their ",(0,l.kt)("inlineCode",{parentName:"p"},"__hash__()")," method from the base object, but their hashability might change if you override the ",(0,l.kt)("inlineCode",{parentName:"p"},"__hash__()")," method. If the ",(0,l.kt)("inlineCode",{parentName:"p"},"__hash__()")," method for the class returns a constant value or is not defined (which results in a constant return value of ",(0,l.kt)("inlineCode",{parentName:"p"},"None"),"), then the instances of that class are not hashable. If ",(0,l.kt)("inlineCode",{parentName:"p"},"__hash__()")," returns a unique and constant value for each object during its lifetime, the instances are hashable."),(0,l.kt)("h4",{id:"related-links"},(0,l.kt)("strong",{parentName:"h4"},"Related Links:")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"../data-types#mutable-vs-immutable-types"},"Mutable vs Immutable Types")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"../data-types#hashability-of-tuples"},"Hashability of Tuples"))),(0,l.kt)("h2",{id:"common-pitfalls"},"Common Pitfalls"),(0,l.kt)("h3",{id:"immutable-but-contain-mutable-elements"},"Immutable But Contain Mutable Elements"),(0,l.kt)("p",null,"A common misunderstanding is to think that because tuples are immutable, their elements are too. This is not true. If a tuple contains a mutable type, like a list, that element can be changed."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="main.py"',title:'"main.py"'},"t = (1, [2, 3], 4)\nt[1].append(5)\nprint(t)  # Outputs (1, [2, 3, 5], 4)\n")),(0,l.kt)("admonition",{type:"caution"},(0,l.kt)("p",{parentName:"admonition"},(0,l.kt)("strong",{parentName:"p"},"A tuple is considered hashable if and only if all its elements are hashable."),"\nTuples containing non-hashable elements are not suitable for use as keys in dictionaries or elements in sets, which require hashable objects.")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Related Links:")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"./tuple#hashability"},"Hashability"))),(0,l.kt)("h3",{id:"single-element-tuples"},"Single Element Tuples"),(0,l.kt)("p",null,"If you want to create a tuple with a single element, you need to include a trailing comma, otherwise Python interprets it as a simple parenthesized expression."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="main.py"',title:'"main.py"'},"not_a_tuple = (50)\nprint(type(not_a_tuple))  # Outputs <class 'int'>\n\na_tuple = (50,)\nprint(type(a_tuple))  # Outputs <class 'tuple'>\n")),(0,l.kt)("h2",{id:"best-practices"},"Best Practices"),(0,l.kt)("h3",{id:"use-when-data-shouldnt-change"},"Use When Data Shouldn't Change"),(0,l.kt)("p",null,"Because tuples are immutable, they're useful for storing a sequence of elements that shouldn't change throughout the course of your program."),(0,l.kt)("p",null,"Tuples are not as flexible as lists because once you create a tuple, you cannot change its contents. However, this feature is advantageous in some situations. For instance, if a function is using a set of values that must not change, using a tuple can prevent accidental modification of those values, which could otherwise lead to bugs or incorrect results."),(0,l.kt)("h3",{id:"unpacking"},"Unpacking"),(0,l.kt)("p",null,"Tuples are commonly used for multiple assignment (also called unpacking)."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="main.py"',title:'"main.py"'},"x, y, z = (1, 2, 3)\nprint(x, y, z)  # Outputs 1 2 3\n")),(0,l.kt)("h3",{id:"return-multiple-values-from-a-function"},"Return Multiple Values from a Function"),(0,l.kt)("p",null,"Functions in Python can return multiple values using tuples."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="main.py"',title:'"main.py"'},"def min_max(nums):\n    return min(nums), max(nums)\n\nprint(min_max([1, 2, 3]))  # Outputs (1, 3)\n")),(0,l.kt)("p",null,"In general, tuples are less flexible than lists or dictionaries because they are immutable, and they do not have the range of methods that lists and dictionaries have. However, they are a basic data type that is used in many different contexts in Python, and understanding them is essential to writing Pythonic code."))}h.isMDXComponent=!0}}]);