"use strict";(self.webpackChunkmy_learning_paths=self.webpackChunkmy_learning_paths||[]).push([[4243],{3905:(t,e,a)=>{a.d(e,{Zo:()=>p,kt:()=>b});var n=a(7294);function s(t,e,a){return e in t?Object.defineProperty(t,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):t[e]=a,t}function r(t,e){var a=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.push.apply(a,n)}return a}function l(t){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{};e%2?r(Object(a),!0).forEach((function(e){s(t,e,a[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(a,e))}))}return t}function i(t,e){if(null==t)return{};var a,n,s=function(t,e){if(null==t)return{};var a,n,s={},r=Object.keys(t);for(n=0;n<r.length;n++)a=r[n],e.indexOf(a)>=0||(s[a]=t[a]);return s}(t,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(n=0;n<r.length;n++)a=r[n],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(s[a]=t[a])}return s}var c=n.createContext({}),o=function(t){var e=n.useContext(c),a=e;return t&&(a="function"==typeof t?t(e):l(l({},e),t)),a},p=function(t){var e=o(t.components);return n.createElement(c.Provider,{value:e},t.children)},m="mdxType",u={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},d=n.forwardRef((function(t,e){var a=t.components,s=t.mdxType,r=t.originalType,c=t.parentName,p=i(t,["components","mdxType","originalType","parentName"]),m=o(a),d=s,b=m["".concat(c,".").concat(d)]||m[d]||u[d]||r;return a?n.createElement(b,l(l({ref:e},p),{},{components:a})):n.createElement(b,l({ref:e},p))}));function b(t,e){var a=arguments,s=e&&e.mdxType;if("string"==typeof t||s){var r=a.length,l=new Array(r);l[0]=d;var i={};for(var c in e)hasOwnProperty.call(e,c)&&(i[c]=e[c]);i.originalType=t,i[m]="string"==typeof t?t:s,l[1]=i;for(var o=2;o<r;o++)l[o]=a[o];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},8293:(t,e,a)=>{a.r(e),a.d(e,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>o});var n=a(7462),s=(a(7294),a(3905));const r={},l="Abstract Class",i={unversionedId:"programming/languages/kotlin/classes/abstract-class",id:"programming/languages/kotlin/classes/abstract-class",title:"Abstract Class",description:"Abstract classes in Kotlin are used as a base class for other classes. An abstract class cannot be instantiated, meaning you cannot create an object of an abstract class. It is used to define a common interface for its subclasses.",source:"@site/docs/programming/languages/kotlin/classes/abstract-class.md",sourceDirName:"programming/languages/kotlin/classes",slug:"/programming/languages/kotlin/classes/abstract-class",permalink:"/programming/languages/kotlin/classes/abstract-class",draft:!1,editUrl:"https://github.com/dennis-gonzales/dennis-gonzales.github.io/blob/main/docs/programming/languages/kotlin/classes/abstract-class.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Companion Object",permalink:"/programming/languages/kotlin/classes/companion-object"},next:{title:"Data Class",permalink:"/programming/languages/kotlin/classes/data-class"}},c={},o=[{value:"Defining an Abstract Class",id:"defining-an-abstract-class",level:2},{value:"Abstract Properties and Functions",id:"abstract-properties-and-functions",level:2},{value:"Implementing an Abstract Class",id:"implementing-an-abstract-class",level:2},{value:"Common Pitfalls and Best Practices",id:"common-pitfalls-and-best-practices",level:2},{value:"Abstract Classes vs. Interfaces",id:"abstract-classes-vs-interfaces",level:3},{value:"Abstract Classes and Open Functions",id:"abstract-classes-and-open-functions",level:3},{value:"Design Patterns",id:"design-patterns",level:2}],p={toc:o},m="wrapper";function u(t){let{components:e,...a}=t;return(0,s.kt)(m,(0,n.Z)({},p,a,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"abstract-class"},"Abstract Class"),(0,s.kt)("p",null,"Abstract classes in Kotlin are used as a base class for other classes. An abstract class cannot be instantiated, meaning you cannot create an object of an abstract class. It is used to define a common interface for its subclasses."),(0,s.kt)("h2",{id:"defining-an-abstract-class"},"Defining an Abstract Class"),(0,s.kt)("p",null,"An abstract class is defined with the ",(0,s.kt)("inlineCode",{parentName:"p"},"abstract")," keyword, followed by the ",(0,s.kt)("inlineCode",{parentName:"p"},"class")," keyword, and the class name."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="AbstractClassDefinition.kt"',title:'"AbstractClassDefinition.kt"'},"abstract class Animal {\n    // Abstract class body goes here\n}\n")),(0,s.kt)("h2",{id:"abstract-properties-and-functions"},"Abstract Properties and Functions"),(0,s.kt)("p",null,"Abstract classes can contain abstract properties and functions. These are properties and functions without a body, and they must be overridden by any non-abstract child class."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="AbstractPropertiesFunctions.kt"',title:'"AbstractPropertiesFunctions.kt"'},"abstract class Animal {\n    abstract val name: String\n\n    abstract fun sound()\n}\n")),(0,s.kt)("p",null,"In the above example, ",(0,s.kt)("inlineCode",{parentName:"p"},"Animal")," is an abstract class with an abstract property ",(0,s.kt)("inlineCode",{parentName:"p"},"name")," and an abstract function ",(0,s.kt)("inlineCode",{parentName:"p"},"sound"),"."),(0,s.kt)("h2",{id:"implementing-an-abstract-class"},"Implementing an Abstract Class"),(0,s.kt)("p",null,"An abstract class is meant to be inherited by other classes. The subclass must provide implementations for the abstract properties and functions of the abstract class."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="ImplementAbstractClass.kt"',title:'"ImplementAbstractClass.kt"'},'abstract class Animal {\n    abstract val name: String\n    abstract fun sound()\n}\n\nclass Dog(override val name: String) : Animal() {\n    override fun sound() {\n        println("The dog barks.")\n    }\n}\n')),(0,s.kt)("p",null,"In the above example, ",(0,s.kt)("inlineCode",{parentName:"p"},"Dog")," is a class that inherits from ",(0,s.kt)("inlineCode",{parentName:"p"},"Animal")," and provides implementations for ",(0,s.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"sound"),"."),(0,s.kt)("h2",{id:"common-pitfalls-and-best-practices"},"Common Pitfalls and Best Practices"),(0,s.kt)("h3",{id:"abstract-classes-vs-interfaces"},"Abstract Classes vs. Interfaces"),(0,s.kt)("p",null,"A common dilemma in object-oriented programming is whether to use an abstract class or an interface when designing large functional units. Abstract classes can have constructor parameters and can maintain state, while interfaces cannot. However, a class can implement multiple interfaces but can only inherit from one abstract class. The choice depends on the design requirements."),(0,s.kt)("h3",{id:"abstract-classes-and-open-functions"},"Abstract Classes and Open Functions"),(0,s.kt)("p",null,"In abstract classes, all functions are 'open' by default, meaning they can be overridden by subclasses. If you do not want a function to be overridden, declare it as 'final'."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="AbstractClassFinalFunction.kt"',title:'"AbstractClassFinalFunction.kt"'},'abstract class Animal {\n    open fun sound() {\n        println("The animal makes a sound.")\n    }\n\n    final fun eat() {\n        println("The animal eats.")\n    }\n}\n')),(0,s.kt)("h2",{id:"design-patterns"},"Design Patterns"),(0,s.kt)("p",null,"In the context of design patterns, abstract classes are used in many ways:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"In the Template Method pattern, an abstract class defines a 'template' of an algorithm, and concrete subclasses implement the abstract steps of the algorithm."),(0,s.kt)("li",{parentName:"ul"},"In the Factory Method pattern, the Creator class is often an abstract class with the Factory Method being an abstract method."),(0,s.kt)("li",{parentName:"ul"},"In the Strategy pattern, the Strategy is often represented as an abstract class, with each ConcreteStrategy being a subclass.")),(0,s.kt)("p",null,"Understanding abstract classes is essential for object-oriented programming in Kotlin. They are a powerful tool for creating reusable and organized code."))}u.isMDXComponent=!0}}]);