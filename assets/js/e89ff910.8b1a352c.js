"use strict";(self.webpackChunkmy_learning_paths=self.webpackChunkmy_learning_paths||[]).push([[4391],{3905:(n,t,e)=>{e.d(t,{Zo:()=>c,kt:()=>f});var i=e(7294);function a(n,t,e){return t in n?Object.defineProperty(n,t,{value:e,enumerable:!0,configurable:!0,writable:!0}):n[t]=e,n}function r(n,t){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(n,t).enumerable}))),e.push.apply(e,i)}return e}function o(n){for(var t=1;t<arguments.length;t++){var e=null!=arguments[t]?arguments[t]:{};t%2?r(Object(e),!0).forEach((function(t){a(n,t,e[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):r(Object(e)).forEach((function(t){Object.defineProperty(n,t,Object.getOwnPropertyDescriptor(e,t))}))}return n}function u(n,t){if(null==n)return{};var e,i,a=function(n,t){if(null==n)return{};var e,i,a={},r=Object.keys(n);for(i=0;i<r.length;i++)e=r[i],t.indexOf(e)>=0||(a[e]=n[e]);return a}(n,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);for(i=0;i<r.length;i++)e=r[i],t.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(n,e)&&(a[e]=n[e])}return a}var s=i.createContext({}),l=function(n){var t=i.useContext(s),e=t;return n&&(e="function"==typeof n?n(t):o(o({},t),n)),e},c=function(n){var t=l(n.components);return i.createElement(s.Provider,{value:t},n.children)},p="mdxType",m={inlineCode:"code",wrapper:function(n){var t=n.children;return i.createElement(i.Fragment,{},t)}},g=i.forwardRef((function(n,t){var e=n.components,a=n.mdxType,r=n.originalType,s=n.parentName,c=u(n,["components","mdxType","originalType","parentName"]),p=l(e),g=a,f=p["".concat(s,".").concat(g)]||p[g]||m[g]||r;return e?i.createElement(f,o(o({ref:t},c),{},{components:e})):i.createElement(f,o({ref:t},c))}));function f(n,t){var e=arguments,a=t&&t.mdxType;if("string"==typeof n||a){var r=e.length,o=new Array(r);o[0]=g;var u={};for(var s in t)hasOwnProperty.call(t,s)&&(u[s]=t[s]);u.originalType=n,u[p]="string"==typeof n?n:a,o[1]=u;for(var l=2;l<r;l++)o[l]=e[l];return i.createElement.apply(null,o)}return i.createElement.apply(null,e)}g.displayName="MDXCreateElement"},1813:(n,t,e)=>{e.r(t),e.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>m,frontMatter:()=>r,metadata:()=>u,toc:()=>l});var i=e(7462),a=(e(7294),e(3905));const r={},o="Functional Programming",u={unversionedId:"programming/languages/typescript/functions/functional-programming",id:"programming/languages/typescript/functions/functional-programming",title:"Functional Programming",description:"Functional programming is a programming paradigm that treats computation as the evaluation of mathematical functions and avoids changing state and mutable data. In this paradigm, functions are first-class citizens, meaning they can be assigned to variables, passed as arguments, and returned from other functions.",source:"@site/docs/programming/languages/typescript/functions/functional-programming.md",sourceDirName:"programming/languages/typescript/functions",slug:"/programming/languages/typescript/functions/functional-programming",permalink:"/programming/languages/typescript/functions/functional-programming",draft:!1,editUrl:"https://github.com/dennis-gonzales/dennis-gonzales.github.io/blob/main/docs/programming/languages/typescript/functions/functional-programming.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Functions",permalink:"/programming/languages/typescript/functions/"},next:{title:"React with TypeScript",permalink:"/programming/languages/typescript/react/"}},s={},l=[{value:"Pure Functions",id:"pure-functions",level:2},{value:"Immutability",id:"immutability",level:2},{value:"Function Composition",id:"function-composition",level:2},{value:"Higher-Order Functions",id:"higher-order-functions",level:2},{value:"Functions as Arguments",id:"functions-as-arguments",level:3},{value:"Function as Return Type",id:"function-as-return-type",level:3},{value:"Functions that Accept and Return Functions",id:"functions-that-accept-and-return-functions",level:3},{value:"Common Pitfalls",id:"common-pitfalls",level:2},{value:"Ignoring Function Purity",id:"ignoring-function-purity",level:3},{value:"Mutating Data",id:"mutating-data",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Use Pure Functions",id:"use-pure-functions",level:3},{value:"Avoid Side Effects",id:"avoid-side-effects",level:3},{value:"Use Functional Programming Libraries",id:"use-functional-programming-libraries",level:3},{value:"Design Patterns",id:"design-patterns",level:2},{value:"Function Composition Pattern",id:"function-composition-pattern",level:3},{value:"Recursion",id:"recursion",level:3}],c={toc:l},p="wrapper";function m(n){let{components:t,...e}=n;return(0,a.kt)(p,(0,i.Z)({},c,e,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"functional-programming"},"Functional Programming"),(0,a.kt)("p",null,"Functional programming is a programming paradigm that treats computation as the evaluation of mathematical functions and avoids changing state and mutable data. In this paradigm, functions are first-class citizens, meaning they can be assigned to variables, passed as arguments, and returned from other functions."),(0,a.kt)("p",null,"TypeScript supports functional programming, as it is a superset of JavaScript, which is a multi-paradigm language that includes functional programming alongside other paradigms."),(0,a.kt)("h2",{id:"pure-functions"},"Pure Functions"),(0,a.kt)("p",null,"A fundamental concept in functional programming is the use of pure functions. A function is considered pure if it always produces the same output for the same set of inputs and does not have any observable side effects."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="PureFunctionExample.ts"',title:'"PureFunctionExample.ts"'},"// highlight-start\nfunction add(a: number, b: number): number {\n  return a + b;\n}\n// highlight-end\n")),(0,a.kt)("h2",{id:"immutability"},"Immutability"),(0,a.kt)("p",null,"In functional programming, data is immutable. This means that it cannot be changed after it is created. If you want to change an object, you create a new one with the desired changes."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="ImmutableExample.ts"',title:'"ImmutableExample.ts"'},"let a = [1, 2, 3];\n// highlight-next-line\nlet b = [...a, 4]; // a is unchanged\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Related Links:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"../variables/deep-dive#immutability"},"Variable Immutability"))),(0,a.kt)("h2",{id:"function-composition"},"Function Composition"),(0,a.kt)("p",null,"Function composition is the process of combining two or more functions to produce a new function. Composing functions together is a common practice in functional programming."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="FunctionCompositionExample.ts"',title:'"FunctionCompositionExample.ts"'},"function double(x: number): number {\n  return x + x;\n}\nfunction increment(x: number): number {\n  return x + 1;\n}\nfunction doubleThenIncrement(x: number): number {\n// highlight-next-line\n  return increment(double(x));\n}\n")),(0,a.kt)("h2",{id:"higher-order-functions"},"Higher-Order Functions"),(0,a.kt)("p",null,"Higher-order functions are functions that take other functions as arguments, return a function, or both."),(0,a.kt)("h3",{id:"functions-as-arguments"},"Functions as Arguments"),(0,a.kt)("p",null,"A common use case for this is applying a custom transformation to data, like mapping an array using a specific function."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="HigherOrderFunctionExample.ts"',title:'"HigherOrderFunctionExample.ts"'},"// highlight-next-line\nfunction applyFunction(arr: number[], fn: (x: number) => number): number[] {\n  return arr.map(fn);\n}\n\nconst double = (x: number) => x * 2;\nconst result = applyFunction([1, 2, 3], double);\nconsole.log(result); // Outputs: [2, 4, 6]\n")),(0,a.kt)("p",null,"Here, ",(0,a.kt)("inlineCode",{parentName:"p"},"applyFunction")," takes an array and a function ",(0,a.kt)("inlineCode",{parentName:"p"},"fn"),", applying ",(0,a.kt)("inlineCode",{parentName:"p"},"fn")," to each element of the array."),(0,a.kt)("h3",{id:"function-as-return-type"},"Function as Return Type"),(0,a.kt)("p",null,"This pattern is useful for creating functions with specific behaviors."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="HigherOrderFunctionExample.ts"',title:'"HigherOrderFunctionExample.ts"'},"function multiplyBy(factor: number) {\n// highlight-next-line\n  return (x: number) => x * factor;\n}\n\nconst triple = multiplyBy(3);\nconsole.log(triple(5)); // Outputs: 15\n")),(0,a.kt)("p",null,"Here, ",(0,a.kt)("inlineCode",{parentName:"p"},"multiplyBy")," returns a new function that multiplies its input by a specific factor. You can create different multiplication functions by calling ",(0,a.kt)("inlineCode",{parentName:"p"},"multiplyBy")," with different arguments."),(0,a.kt)("h3",{id:"functions-that-accept-and-return-functions"},"Functions that Accept and Return Functions"),(0,a.kt)("p",null,"This pattern combines the previous two, allowing for powerful composition and customization."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="HigherOrderFunctionExample.ts"',title:'"HigherOrderFunctionExample.ts"'},"import _ from 'lodash';\n\nconst double = (x: number) => x * 2;\nconst increment = (x: number) => x + 1;\n\n// Using _.flow to compose the functions\n// highlight-next-line\nconst doubleThenIncrement = _.flow([double, increment]);\n\nconsole.log(doubleThenIncrement(3)); // Outputs: 7\n")),(0,a.kt)("p",null,"In this example, Lodash's ",(0,a.kt)("inlineCode",{parentName:"p"},"_.flow")," method takes an array of functions and returns a new function that represents their composition. When called with an argument, the composed function passes that argument through each function in the array, in order."),(0,a.kt)("admonition",{title:"Utilize libraries like Lodash to simplify function composition.",type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"The ",(0,a.kt)("inlineCode",{parentName:"p"},"_.flow")," method in Lodash allows you to easily combine multiple functions into a ",(0,a.kt)("a",{parentName:"p",href:"#function-composition"},(0,a.kt)("strong",{parentName:"a"},"single composed function")),"."),(0,a.kt)("p",{parentName:"admonition"},"For example, ",(0,a.kt)("inlineCode",{parentName:"p"},"const composedFn = _.flow([fn1, fn2, fn3]);")," creates a new function that passes its input through ",(0,a.kt)("inlineCode",{parentName:"p"},"fn1"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"fn2"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"fn3")," in sequence. It's a handy way to create complex functionality from simple building blocks.")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Related Links:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"./#anonymous-functions"},"Anonymous Functions")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"./#callbacks"},"Callback Functions"))),(0,a.kt)("h2",{id:"common-pitfalls"},"Common Pitfalls"),(0,a.kt)("h3",{id:"ignoring-function-purity"},"Ignoring Function Purity"),(0,a.kt)("p",null,"A key principle of functional programming is to use pure functions, as they have predictable outputs and no side effects. Ignoring function purity can lead to bugs that are hard to trace and debug."),(0,a.kt)("h3",{id:"mutating-data"},"Mutating Data"),(0,a.kt)("p",null,"Mutating data can lead to unexpected behavior in your code. In functional programming, it's better to return a new copy with the changes applied."),(0,a.kt)("h2",{id:"best-practices"},"Best Practices"),(0,a.kt)("h3",{id:"use-pure-functions"},"Use Pure Functions"),(0,a.kt)("p",null,"Whenever possible, use pure functions. They're easier to reason about and test because they don't depend on or alter anything outside of their scope."),(0,a.kt)("h3",{id:"avoid-side-effects"},"Avoid Side Effects"),(0,a.kt)("p",null,"Avoid functions that cause side effects. Side effects could be anything that affects the state of the application outside of the scope of the function."),(0,a.kt)("h3",{id:"use-functional-programming-libraries"},"Use Functional Programming Libraries"),(0,a.kt)("p",null,"Consider using a functional programming library like lodash/fp or Ramda. These libraries provide utility functions that make it easier to write functional code."),(0,a.kt)("h2",{id:"design-patterns"},"Design Patterns"),(0,a.kt)("p",null,"In functional programming, design patterns are different than the traditional ones found in object-oriented programming. Here are a few examples:"),(0,a.kt)("h3",{id:"function-composition-pattern"},"Function Composition Pattern"),(0,a.kt)("p",null,"Function composition is a fundamental design pattern in functional programming. It allows you to build complex logic from simple, reusable functions."),(0,a.kt)("h3",{id:"recursion"},"Recursion"),(0,a.kt)("p",null,"Since functional programming avoids mutable state, recursion is often used where you might traditionally use a loop to iterate over data."))}m.isMDXComponent=!0}}]);