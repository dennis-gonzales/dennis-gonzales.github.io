"use strict";(self.webpackChunkmy_learning_paths=self.webpackChunkmy_learning_paths||[]).push([[1658],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>g});var n=a(7294);function l(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){l(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,n,l=function(e,t){if(null==e)return{};var a,n,l={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(l[a]=e[a]);return l}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},u=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,l=e.mdxType,i=e.originalType,s=e.parentName,u=r(e,["components","mdxType","originalType","parentName"]),m=p(a),d=l,g=m["".concat(s,".").concat(d)]||m[d]||c[d]||i;return a?n.createElement(g,o(o({ref:t},u),{},{components:a})):n.createElement(g,o({ref:t},u))}));function g(e,t){var a=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var i=a.length,o=new Array(i);o[0]=d;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r[m]="string"==typeof e?e:l,o[1]=r;for(var p=2;p<i;p++)o[p]=a[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},7955:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>r,toc:()=>p});var n=a(7462),l=(a(7294),a(3905));const i={},o="Maps",r={unversionedId:"programming/languages/kotlin/data-types/collections/maps",id:"programming/languages/kotlin/data-types/collections/maps",title:"Maps",description:"A Map in Kotlin is an interface and generic collection of elements that holds data as Key/Value pairs. In a Map, keys are unique. This means that a single Map can't have duplicate keys. However, it can have duplicate values.",source:"@site/docs/programming/languages/kotlin/data-types/collections/maps.md",sourceDirName:"programming/languages/kotlin/data-types/collections",slug:"/programming/languages/kotlin/data-types/collections/maps",permalink:"/programming/languages/kotlin/data-types/collections/maps",draft:!1,editUrl:"https://github.com/dennis-gonzales/dennis-gonzales.github.io/blob/main/docs/programming/languages/kotlin/data-types/collections/maps.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Lists",permalink:"/programming/languages/kotlin/data-types/collections/lists"},next:{title:"Sets",permalink:"/programming/languages/kotlin/data-types/collections/sets"}},s={},p=[{value:"Defining a Map",id:"defining-a-map",level:2},{value:"Accessing Elements",id:"accessing-elements",level:2},{value:"Modifying a MutableMap",id:"modifying-a-mutablemap",level:2},{value:"Common Pitfalls and Best Practices",id:"common-pitfalls-and-best-practices",level:2},{value:"Map vs List or Set",id:"map-vs-list-or-set",level:3},{value:"Mutable vs Immutable Maps",id:"mutable-vs-immutable-maps",level:3},{value:"Null Safety",id:"null-safety",level:3},{value:"Design Patterns",id:"design-patterns",level:2}],u={toc:p},m="wrapper";function c(e){let{components:t,...a}=e;return(0,l.kt)(m,(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"maps"},"Maps"),(0,l.kt)("p",null,"A Map in Kotlin is an interface and generic collection of elements that holds data as ",(0,l.kt)("inlineCode",{parentName:"p"},"Key/Value")," pairs. In a Map, keys are unique. This means that a single Map can't have duplicate keys. However, it can have duplicate values."),(0,l.kt)("h2",{id:"defining-a-map"},"Defining a Map"),(0,l.kt)("p",null,"A map is defined using the ",(0,l.kt)("inlineCode",{parentName:"p"},"mapOf")," function for an immutable map or the ",(0,l.kt)("inlineCode",{parentName:"p"},"mutableMapOf")," function for a mutable map."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="DefineMap.kt"',title:'"DefineMap.kt"'},'val immutableMap = mapOf(1 to "one", 2 to "two", 3 to "three")\nval mutableMap = mutableMapOf(1 to "one", 2 to "two", 3 to "three")\n')),(0,l.kt)("h2",{id:"accessing-elements"},"Accessing Elements"),(0,l.kt)("p",null,"You can access a value of a map by its key."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="AccessElements.kt"',title:'"AccessElements.kt"'},'val numbers = mapOf(1 to "one", 2 to "two", 3 to "three")\nprintln(numbers[2]) // Prints: two\n')),(0,l.kt)("h2",{id:"modifying-a-mutablemap"},"Modifying a MutableMap"),(0,l.kt)("p",null,"You can add or remove entries in a MutableMap."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="ModifyMutableMap.kt"',title:'"ModifyMutableMap.kt"'},'val numbers = mutableMapOf(1 to "one", 2 to "two", 3 to "three")\nnumbers[4] = "four"\nnumbers.remove(1)\nprintln(numbers) // Prints: {2=two, 3=three, 4=four}\n')),(0,l.kt)("h2",{id:"common-pitfalls-and-best-practices"},"Common Pitfalls and Best Practices"),(0,l.kt)("h3",{id:"map-vs-list-or-set"},"Map vs List or Set"),(0,l.kt)("p",null,"A map can be thought of as a set of key-value pairs. It's useful when you need to associate data (the values) with unique identifiers (the keys). A map is not the best choice of data structure if you don't need to associate values with keys - in those cases, a list or set might be a better option."),(0,l.kt)("h3",{id:"mutable-vs-immutable-maps"},"Mutable vs Immutable Maps"),(0,l.kt)("p",null,"A mutable map allows for modification after its creation (adding, removing entries), while an immutable map does not. Using an immutable map can make your code safer from bugs and easier to reason about, since you know it cannot be changed after it's created."),(0,l.kt)("h3",{id:"null-safety"},"Null Safety"),(0,l.kt)("p",null,"Kotlin's null safety features also apply to maps. If a map can contain null values, you need to declare the value type as nullable."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="NullableMap.kt"',title:'"NullableMap.kt"'},'val numbers: Map<Int, String?> = mapOf(1 to "one", 2 to "two", 3 to null)\n')),(0,l.kt)("h2",{id:"design-patterns"},"Design Patterns"),(0,l.kt)("p",null,"In the context of design patterns, maps are used in various ways:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"In the Flyweight pattern, a map can be used to store and retrieve shared flyweights."),(0,l.kt)("li",{parentName:"ul"},"In the Composite pattern, a map can be used to store child components in a composite, with keys serving as identifiers."),(0,l.kt)("li",{parentName:"ul"},"In the Prototype pattern, a map can be used to store original objects to clone.")),(0,l.kt)("p",null,"Maps are a useful tool when you need to store data as key-value pairs. Understanding how to use maps effectively is an essential skill in Kotlin programming."))}c.isMDXComponent=!0}}]);