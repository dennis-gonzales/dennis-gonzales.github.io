"use strict";(self.webpackChunkmy_learning_paths=self.webpackChunkmy_learning_paths||[]).push([[7574],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>y});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var o=a.createContext({}),p=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(o.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=p(n),m=i,y=c["".concat(o,".").concat(m)]||c[m]||d[m]||r;return n?a.createElement(y,l(l({ref:t},u),{},{components:n})):a.createElement(y,l({ref:t},u))}));function y(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=m;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s[c]="string"==typeof e?e:i,l[1]=s;for(var p=2;p<r;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},1323:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var a=n(7462),i=(n(7294),n(3905));const r={sidebar_position:2},l="Data Types",s={unversionedId:"programming/languages/typescript/data-types/index",id:"programming/languages/typescript/data-types/index",title:"Data Types",description:"Data types are a fundamental concept in any programming language. They define the type of data that a variable can hold. TypeScript, a statically typed superset of JavaScript, introduces additional data types to help make your code more robust and type-safe.",source:"@site/docs/programming/languages/typescript/data-types/index.mdx",sourceDirName:"programming/languages/typescript/data-types",slug:"/programming/languages/typescript/data-types/",permalink:"/programming/languages/typescript/data-types/",draft:!1,editUrl:"https://github.com/dennis-gonzales/dennis-gonzales.github.io/blob/main/docs/programming/languages/typescript/data-types/index.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Deep Dive",permalink:"/programming/languages/typescript/variables/deep-dive"},next:{title:"Functions",permalink:"/programming/languages/typescript/functions/"}},o={},p=[{value:"Primitive Types",id:"primitive-types",level:2},{value:"Boolean",id:"boolean",level:3},{value:"Number",id:"number",level:3},{value:"String",id:"string",level:3},{value:"Null and Undefined",id:"null-and-undefined",level:3},{value:"Non-Primitive Types",id:"non-primitive-types",level:2},{value:"Array",id:"array",level:3},{value:"Tuple",id:"tuple",level:3},{value:"Object",id:"object",level:3},{value:"Type Annotations",id:"type-annotations",level:2},{value:"Any",id:"any",level:3},{value:"Void",id:"void",level:3},{value:"Never",id:"never",level:3},{value:"Enum Type",id:"enum-type",level:2},{value:"Union Types",id:"union-types",level:2},{value:"Common Pitfalls",id:"common-pitfalls",level:2},{value:"Confusing Primitives with Object Wrappers",id:"confusing-primitives-with-object-wrappers",level:3},{value:"Misusing Any",id:"misusing-any",level:3},{value:"Not Using Strict Null Checks",id:"not-using-strict-null-checks",level:3},{value:"Not Understanding Union Types",id:"not-understanding-union-types",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Use Aliases for Complex Union Types",id:"use-aliases-for-complex-union-types",level:3},{value:"Use Const Assertions",id:"use-const-assertions",level:3},{value:"Use Optional Types for Optional Properties",id:"use-optional-types-for-optional-properties",level:3},{value:"Exhaustive type checking with Never",id:"exhaustive-type-checking-with-never",level:3}],u={toc:p},c="wrapper";function d(e){let{components:t,...n}=e;return(0,i.kt)(c,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"data-types"},"Data Types"),(0,i.kt)("p",null,"Data types are a fundamental concept in any programming language. They define the type of data that a variable can hold. TypeScript, a statically typed superset of JavaScript, introduces additional data types to help make your code more robust and type-safe."),(0,i.kt)("h2",{id:"primitive-types"},"Primitive Types"),(0,i.kt)("p",null,"Primitive types are ",(0,i.kt)("a",{parentName:"p",href:"./variables/deep-dive#immutable"},"immutable")," and ",(0,i.kt)("a",{parentName:"p",href:"./variables/deep-dive#pass-by-value"},"passed by value"),"."),(0,i.kt)("h3",{id:"boolean"},"Boolean"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"boolean")," type has two values: ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),". This type is commonly used for flags that enable or disable features."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="BooleanExample.ts"',title:'"BooleanExample.ts"'},"let isDone: boolean = false;\n")),(0,i.kt)("h3",{id:"number"},"Number"),(0,i.kt)("p",null,"In TypeScript, all numbers are floating-point values. The ",(0,i.kt)("inlineCode",{parentName:"p"},"number")," type includes standard numeric values, as well as NaN and Infinity."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="NumberExample.ts"',title:'"NumberExample.ts"'},"let decimal: number = 6;\nlet hex: number = 0xf00d;\nlet binary: number = 0b1010;\nlet octal: number = 0o744;\n")),(0,i.kt)("h3",{id:"string"},"String"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"string")," type is used to represent textual data. You can use single (",(0,i.kt)("inlineCode",{parentName:"p"},"'"),") or double (",(0,i.kt)("inlineCode",{parentName:"p"},'"'),") quotes to surround your string data."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="StringExample.ts"',title:'"StringExample.ts"'},"let color: string = \"blue\";\ncolor = 'red';\n")),(0,i.kt)("h3",{id:"null-and-undefined"},"Null and Undefined"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"undefined")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," have their own types named ",(0,i.kt)("inlineCode",{parentName:"p"},"undefined")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", respectively. By default, these types are subtypes of all other types."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="NullUndefinedExample.ts"',title:'"NullUndefinedExample.ts"'},"let u: undefined = undefined;\nlet n: null = null;\n")),(0,i.kt)("admonition",{title:"Immutability in Primitive data types",type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"When you reassign a variable holding a primitive value using ",(0,i.kt)("inlineCode",{parentName:"p"},"="),", you aren't changing the value itself. Instead, you're creating a new value and updating the variable to reference this new value. The original value remains immutable. "),(0,i.kt)("p",{parentName:"admonition"},"This distinction is crucial in understanding how data behaves in TypeScript and JavaScript, especially when discussing concepts like ",(0,i.kt)("a",{parentName:"p",href:"./variables/deep-dive#pass-by-value"},(0,i.kt)("strong",{parentName:"a"},"pass-by-value"))," and ",(0,i.kt)("a",{parentName:"p",href:"./variables/deep-dive#immutability"},(0,i.kt)("strong",{parentName:"a"},"immutability")),".")),(0,i.kt)("h2",{id:"non-primitive-types"},"Non-Primitive Types"),(0,i.kt)("p",null,"Non-primitive types are mutable and ",(0,i.kt)("a",{parentName:"p",href:"./variables/deep-dive#call-by-sharing"},"passed by object reference (call by sharing)"),"."),(0,i.kt)("h3",{id:"array"},"Array"),(0,i.kt)("p",null,"Arrays are used to store multiple values in a single variable. In TypeScript, you can define an array in two ways."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="ArrayExample.ts"',title:'"ArrayExample.ts"'},"let list1: number[] = [1, 2, 3];\nlet list2: Array<number> = [1, 2, 3];  // generic array type\n")),(0,i.kt)("h3",{id:"tuple"},"Tuple"),(0,i.kt)("p",null,"Tuple types allow you to express an array where the type of a fixed number of elements is known, but need not be the same."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="TupleExample.ts"',title:'"TupleExample.ts"'},'let x: [string, number];\nx = ["hello", 10]; // OK\n')),(0,i.kt)("h3",{id:"object"},"Object"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"object")," represents the non-primitive type in TypeScript, i.e., anything that is not ",(0,i.kt)("inlineCode",{parentName:"p"},"number"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"boolean"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"symbol"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", or ",(0,i.kt)("inlineCode",{parentName:"p"},"undefined"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="ObjectExample.ts"',title:'"ObjectExample.ts"'},"declare function create(o: object | null): void;\n\ncreate({ prop: 0 }); // OK\ncreate(null); // OK\n")),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},'The "declare" keyword in TypeScript is used to define type declarations without providing an implementation. '),(0,i.kt)("p",{parentName:"admonition"},'It\'s often used in ".d.ts" files to describe the types of existing JavaScript libraries or global variables, allowing TypeScript to type-check code that uses those libraries or global objects without needing the actual source code.')),(0,i.kt)("h2",{id:"type-annotations"},"Type Annotations"),(0,i.kt)("h3",{id:"any"},"Any"),(0,i.kt)("p",null,"We may need to describe the type of variables that we do not know when we are writing an application. The ",(0,i.kt)("inlineCode",{parentName:"p"},"any")," type comes in handy here."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="AnyExample.ts"',title:'"AnyExample.ts"'},'let notSure: any = 4;\nnotSure = "maybe a string instead";\n')),(0,i.kt)("h3",{id:"void"},"Void"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"void")," is a little like the opposite of ",(0,i.kt)("inlineCode",{parentName:"p"},"any"),". It's the absence of having any type at all. You may commonly see this as the return type of functions that do not return a value."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="VoidExample.ts"',title:'"VoidExample.ts"'},'function warnUser(): void {\n    console.log("This is my warning message");\n}\n')),(0,i.kt)("h3",{id:"never"},"Never"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"never")," type represents the type of values that never occur. For instance, ",(0,i.kt)("inlineCode",{parentName:"p"},"never")," is the return type for a function expression or an arrow function expression that always throws an exception or one that never returns."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="NeverExample.ts"',title:'"NeverExample.ts"'},"function error(message: string): never {\n    throw new Error(message);\n}\n")),(0,i.kt)("h2",{id:"enum-type"},"Enum Type"),(0,i.kt)("p",null,"Enums allow us to define a set of named constants. By default, enums begin numbering their members starting at 0."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="EnumExample.ts"',title:'"EnumExample.ts"'},"enum Color {Red, Green, Blue}\nlet c: Color = Color.Green;\n")),(0,i.kt)("h2",{id:"union-types"},"Union Types"),(0,i.kt)("p",null,"Union types are a powerful way to express a variable with multiple types."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="UnionExample.ts"',title:'"UnionExample.ts"'},"let multiType: number | boolean;\nmultiType = 20;\nmultiType = true;\n")),(0,i.kt)("h2",{id:"common-pitfalls"},"Common Pitfalls"),(0,i.kt)("h3",{id:"confusing-primitives-with-object-wrappers"},"Confusing Primitives with Object Wrappers"),(0,i.kt)("p",null,"Typescript has corresponding object wrappers for primitive types like Number, String, and Boolean. These can lead to confusion."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Object Wrapper"',title:'"Object','Wrapper"':!0},'let numObject: Number = new Number(42);\nlet strObject: String = new String("Hello");\nlet boolObject: Boolean = new Boolean(true);\n\nconsole.log(numObject + 1); // 43\nconsole.log(strObject + " World!"); // "Hello World!"\nconsole.log(!boolObject); // false\n\n// Object wrappers can lead to confusion:\nconsole.log(typeof numObject); // "object", not "number" as one might expect\nconsole.log(typeof strObject); // "object", not "string" as one might expect\nconsole.log(typeof boolObject); // "object", not "boolean" as one might expect\n\n// The following equality checks would fail\nconsole.log(numObject === 42); // false\nconsole.log(strObject === "Hello"); // false\nconsole.log(boolObject === true); // false\n\n')),(0,i.kt)("p",null,"Prefer using primitive types instead of their object wrappers as it can prevent unexpected behavior."),(0,i.kt)("h3",{id:"misusing-any"},"Misusing Any"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"any")," type in TypeScript allows you to assign any type of value to a variable. While this can be convenient in some scenarios, it also disables all type checking and should therefore be avoided if possible."),(0,i.kt)("h3",{id:"not-using-strict-null-checks"},"Not Using Strict Null Checks"),(0,i.kt)("p",null,"By default, values like ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"undefined")," are assignable to any other type. This can lead to unexpected bugs. To avoid this, enable the ",(0,i.kt)("inlineCode",{parentName:"p"},"strictNullChecks")," option in your ",(0,i.kt)("inlineCode",{parentName:"p"},"tsconfig.json"),"."),(0,i.kt)("h3",{id:"not-understanding-union-types"},"Not Understanding Union Types"),(0,i.kt)("p",null,"When using union types, TypeScript only allows you to assign values that are assignable to at least one of the types in the union. If you try to assign a value that isn't assignable to any type in the union, you'll get a type error."),(0,i.kt)("h2",{id:"best-practices"},"Best Practices"),(0,i.kt)("h3",{id:"use-aliases-for-complex-union-types"},"Use Aliases for Complex Union Types"),(0,i.kt)("p",null,"If you have a union type that's used in many places, consider using a type alias to avoid repetition."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="TypeAliasExample.ts"',title:'"TypeAliasExample.ts"'},'type StringOrNumber = string | number;\nlet sample: StringOrNumber;\nsample = 123;\nsample = "123";\n')),(0,i.kt)("h3",{id:"use-const-assertions"},"Use Const Assertions"),(0,i.kt)("p",null,"When declaring a variable with an object or array literal, use a const assertion to avoid unwanted type widening."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="ConstAssertionExample.ts"',title:'"ConstAssertionExample.ts"'},"const obj = { x: 3 } as const;\n")),(0,i.kt)("h3",{id:"use-optional-types-for-optional-properties"},"Use Optional Types for Optional Properties"),(0,i.kt)("p",null,"If an object property might not exist, use the ",(0,i.kt)("inlineCode",{parentName:"p"},"?")," operator to mark it as optional."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="OptionalTypeExample.ts"',title:'"OptionalTypeExample.ts"'},"type MyType = {\n  a: number;\n  b?: string;\n};\n")),(0,i.kt)("h3",{id:"exhaustive-type-checking-with-never"},"Exhaustive type checking with Never"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"type Shape = { kind: 'circle', radius: number } | { kind: 'square', sideLength: number };\n\nfunction assertNever(x: never): never {\n    throw new Error('Unexpected object: ' + JSON.stringify(x));\n}\n\nfunction getArea(shape: Shape): number {\n    switch (shape.kind) {\n        case 'circle':\n            return Math.PI * shape.radius ** 2;\n        case 'square':\n            return shape.sideLength ** 2;\n        default:\n            // highlight-next-line\n            return assertNever(shape); // Error if any cases are missed\n    }\n}\n\nconst circle: Shape = { kind: 'circle', radius: 5 };\nconst square: Shape = { kind: 'a', sideLength: 4 };\n// This will error\n// const invalid: Shape = { kind: 'invalid', sideLength: 4 };\n\nconst circleArea = getArea(circle); // Returns area of the circle\nconst squareArea = getArea(square); // Returns area of the square\n// This will error\n// const invalidArea = getArea(invalid); // Returns area of the invalid\n\nconsole.log(`Area of the circle: ${circleArea}`);\nconsole.log(`Area of the square: ${squareArea}`);\n\n// positive response\n// [LOG]: \"Area of the circle: 78.53981633974483\" \n// [LOG]: \"Area of the square: 16\" \n\n// negative response\n// [ERR]: Unexpected object: {\"kind\":\"invalid\",\"sideLength\":4}\n")))}d.isMDXComponent=!0}}]);