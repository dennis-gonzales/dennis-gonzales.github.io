"use strict";(self.webpackChunkmy_learning_paths=self.webpackChunkmy_learning_paths||[]).push([[9101],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>d});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),c=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=c(e.components);return a.createElement(s.Provider,{value:n},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},f=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=c(t),f=r,d=u["".concat(s,".").concat(f)]||u[f]||m[f]||i;return t?a.createElement(d,o(o({ref:n},p),{},{components:t})):a.createElement(d,o({ref:n},p))}));function d(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=f;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[u]="string"==typeof e?e:r,o[1]=l;for(var c=2;c<i;c++)o[c]=t[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}f.displayName="MDXCreateElement"},8132:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var a=t(7462),r=(t(7294),t(3905));const i={},o="Deep Dive",l={unversionedId:"programming/languages/kotlin/functions/deep-dive",id:"programming/languages/kotlin/functions/deep-dive",title:"Deep Dive",description:"Pass-by-sharing in Kotlin",source:"@site/docs/programming/languages/kotlin/functions/deep-dive.md",sourceDirName:"programming/languages/kotlin/functions",slug:"/programming/languages/kotlin/functions/deep-dive",permalink:"/programming/languages/kotlin/functions/deep-dive",draft:!1,editUrl:"https://github.com/dennis-gonzales/dennis-gonzales.github.io/blob/main/docs/programming/languages/kotlin/functions/deep-dive.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Functions",permalink:"/programming/languages/kotlin/functions/"},next:{title:"Classes",permalink:"/programming/languages/kotlin/classes/"}},s={},c=[{value:"Pass-by-sharing in Kotlin",id:"pass-by-sharing-in-kotlin",level:2},{value:"Modification of Object",id:"modification-of-object",level:3},{value:"Reassignment of Reference",id:"reassignment-of-reference",level:3},{value:"Example",id:"example",level:2}],p={toc:c},u="wrapper";function m(e){let{components:n,...t}=e;return(0,r.kt)(u,(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"deep-dive"},"Deep Dive"),(0,r.kt)("h2",{id:"pass-by-sharing-in-kotlin"},"Pass-by-sharing in Kotlin"),(0,r.kt)("p",null,'In Kotlin, when an object is passed to a function, a copy of the reference to that object is passed, not the actual object itself. This concept is known as "pass-by-sharing" or "call-by-sharing". This is similar to the concept of "pass-by-reference" in some languages, but with an important difference: In "pass-by-reference", you can change the original reference itself, which isn\'t possible in "pass-by-sharing".'),(0,r.kt)("h3",{id:"modification-of-object"},"Modification of Object"),(0,r.kt)("p",null,'When you modify the object\'s fields within a function (for example, car.color = "Red"), these changes are reflected in the original object. This is because both the original reference and the copied reference (which is passed to the function) point to the same object in memory.'),(0,r.kt)("h3",{id:"reassignment-of-reference"},"Reassignment of Reference"),(0,r.kt)("p",null,'If you try to reassign the reference to a new object within the function (like car = Car("Blue")), this change doesn\'t affect the original object. The new assignment creates a new object and assigns the copied reference to it, while the original reference still points to the original object.'),(0,r.kt)("h2",{id:"example"},"Example"),(0,r.kt)("p",null,'Let\'s start with the basics. In Kotlin, all variables are references to objects. When you pass a variable to a function, what is actually passed is the reference to the object, not the object itself. This is why it\'s called "pass-by-sharing" or "call-by-sharing".'),(0,r.kt)("p",null,"Now let's create an example to illustrate these concepts."),(0,r.kt)("p",null,"Let's define a simple ",(0,r.kt)("inlineCode",{parentName:"p"},"Car")," class in Kotlin:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="Main.kt"',title:'"Main.kt"'},"class Car(var color: String)\n")),(0,r.kt)("p",null,"Here, ",(0,r.kt)("inlineCode",{parentName:"p"},"Car")," is a class with a mutable property ",(0,r.kt)("inlineCode",{parentName:"p"},"color"),"."),(0,r.kt)("p",null,"Now, let's create a function ",(0,r.kt)("inlineCode",{parentName:"p"},"paintCar")," that accepts a ",(0,r.kt)("inlineCode",{parentName:"p"},"Car")," object and changes its color:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="Main.kt"',title:'"Main.kt"'},"fun paintCar(car: Car, newColor: String) {\n    car.color = newColor\n}\n")),(0,r.kt)("p",null,"In this function, we're modifying the ",(0,r.kt)("inlineCode",{parentName:"p"},"color")," property of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Car")," object."),(0,r.kt)("p",null,"Let's create a ",(0,r.kt)("inlineCode",{parentName:"p"},"Car")," object and call ",(0,r.kt)("inlineCode",{parentName:"p"},"paintCar"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="Main.kt"',title:'"Main.kt"'},'val myCar = Car("Blue")\nprintln(myCar.color)  // Prints: Blue\n\npaintCar(myCar, "Red")\nprintln(myCar.color)  // Prints: Red\n')),(0,r.kt)("p",null,"In this case, we can see that the changes made to ",(0,r.kt)("inlineCode",{parentName:"p"},"car")," inside ",(0,r.kt)("inlineCode",{parentName:"p"},"paintCar")," are reflected in ",(0,r.kt)("inlineCode",{parentName:"p"},"myCar")," after the function call. This is because ",(0,r.kt)("inlineCode",{parentName:"p"},"car")," inside the function and ",(0,r.kt)("inlineCode",{parentName:"p"},"myCar")," outside the function are references to the same object."),(0,r.kt)("p",null,"Now, let's create another function ",(0,r.kt)("inlineCode",{parentName:"p"},"buyNewCar")," that tries to reassign the ",(0,r.kt)("inlineCode",{parentName:"p"},"car")," reference:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="Main.kt"',title:'"Main.kt"'},"fun buyNewCar(car: Car, newColor: String) {\n    car = Car(newColor)\n}\n")),(0,r.kt)("p",null,"If we call this function with ",(0,r.kt)("inlineCode",{parentName:"p"},"myCar"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="Main.kt"',title:'"Main.kt"'},'buyNewCar(myCar, "Green")\nprintln(myCar.color)  // Prints: Red\n')),(0,r.kt)("p",null,"We can see that the color of ",(0,r.kt)("inlineCode",{parentName:"p"},"myCar")," hasn't changed. This is because the reassignment ",(0,r.kt)("inlineCode",{parentName:"p"},"car = Car(newColor)")," inside ",(0,r.kt)("inlineCode",{parentName:"p"},"buyNewCar")," only affects the ",(0,r.kt)("inlineCode",{parentName:"p"},"car")," reference inside the function, not the ",(0,r.kt)("inlineCode",{parentName:"p"},"myCar")," reference outside the function. The ",(0,r.kt)("inlineCode",{parentName:"p"},"car")," reference inside the function is a copy of the ",(0,r.kt)("inlineCode",{parentName:"p"},"myCar")," reference, so changing the ",(0,r.kt)("inlineCode",{parentName:"p"},"car")," reference doesn't affect the ",(0,r.kt)("inlineCode",{parentName:"p"},"myCar")," reference."),(0,r.kt)("p",null,'This demonstrates the concept of "pass-by-sharing" or "call-by-sharing" in Kotlin. The function receives a copy of the reference, so it can modify the object that the reference points to, but it can\'t change what the original reference points to.'))}m.isMDXComponent=!0}}]);